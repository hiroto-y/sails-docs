#Sailsのセッションを理解する

**セッション**の目的はいくつかのコンポーネントを同期することで同じユーザエージェントの複数のリクエストの間で情報を共有することです。

>**ユーザエージェント**はデバイス上（ブラウザタブやスマートフォンアプリケーション、冷蔵庫など）においてあなたを代表するソフトウエア（ブラウザやネイティブアプリケーション）です。これはクッキーやアクセストークンと1対1で結びついています。 

リクエストとレスポンスのサイクルは**ステートレス**ですのでセッションは非常に有用です。リクエストとレスポンスのサイクルがステートレスとみなされる理由は本質的にはクライアントもサーバも特定のリクエストと別のリクエストを区別するデータを持たないからです。そのためリクエストとレスポンスのライフサイクルはユーザエージェントのリクエストに対するレスポンスが作成された時点で（例：`res.send()`）終了します。

ちなみに、これから議論する内容はブラウザユーザーエージェントでの話です。Sailsのなかでセッションは好きなような目的で使えることができますが、一般的に使われる目的は単にユーザの認証を保存するために使われる目的です。認証とはユーザーエージェントが何らかのアイデンティティを持っていることを確認する作業です。例えば何らかの保護された機能を使うときにブラウザタブがデータベースの中の特定のユーザーデータに結びついているかを確認しなければならないかもしれません。もし私がユニークな名前とパスワードを提供すればあなたは名前を探しだして（暗号化されていればいいのですが、）保存されているパスワード比較することができます。もしそれらが一致すれば私は認証されたことになります。しかし、どうやって「認証されていること」を保存すればいいのでしょうか。そこでセッションの出番なのです。

###セッションは何から出来ているのでしょうか
Sailsでのセッションの実装は3つの主な要素から成り立っています。s:
1. 情報を保管する**セッションストア**
2. セッションを管理するミドルウエア
3. セッションIDを保管しアクセスごとに送信されるクッキー(デフォルトでは`sails.sid`)

この**セッションストア**はメモリの中（例えばSailsのデフォルトのセッションストア）にあってもデータベースの中（Sailsにはこの目的でのRedisのサポートがあります）にあっても構いません。Sailsはセッションを管理する目的でConnectミドルウエアの一番上にミドルウエアを構築し、それはユーザエージェントのセッションID(`sid`)を保管するために**クッキー**を使います。

###*request*と*response*と*session*の日常
`request`がSailsに送信されるとセッションミドルウエアによってリクエストヘッダーがパースされます。 

##### シナリオ１: リクエストヘッダーが*cookie property*を持たない場合

もしヘッダーがクッキープロパティを持たない場合、`sid`がセッションの中に作成され、デフォルトのセッションディレクトリが`req`（例えば`req.session`）に追加されます。この時点でセッションプロパティを変更（通常コントローラアクションで）することが出来ます。例えば、以下の様な*login* を見てみましょう。 

```javascript
module.exports = {
  
  login: function(req, res) {

    // ここに認証コードが入ります。

    // もし、認証に成功したら

    req.session.userId = foundUser.id;   // データベースから返ってきたものです

    return res.json(foundUser);

  }
}
```

`req.session`に`userId`が追加されました。  

> **備考:** レスポンスが返されるまでプロパティは*セッションストア*に保存されませんし、他のリクエストから利用可能にもなりません。

一度レスポンスが送信されるとすべての新規リクエストは`req.session.userId`にアクセス可能になります。クッキーの*プロパティ*はリクエストヘッダーに存在しませんでしたからこのためにクッキーが新しく作成されます。

##### シナリオ2: リクエストヘッダーが`Sails.sid`の*property*を持っている時

ユーザエージェントが次のリクエストをスるとき、クッキーに格納された`Sails.sid`は自動的に確認されセッションストアに保管された`sid`とマッチされればセッションストアの内容は`req`ディレクトリ(例えば`req.session`)のプロパティに保存されます。`req.session`のプロパティ(例：`req.session.me`)にアクセスしたりそこに内容を追加したり(例：`req.session.me == someValue`)出来ます。セッションストアの値は変わることがありますが通常`Sails.sid`と`sid`は変わることがありません。

### `Sails.sid`はいつ変更されますか
デフォルトではセッションストアは*インメモリ*です。そのためSailのサーバを閉じた時に現在のセッションデータはセッション天国に行ってしまいます。（つまりセッションストアは消え去ります）Sailsがリスタートした時仮にユーザエージェントのリクエストのクッキーの中に`Sails.sid`が存在してもセッションストアには`sid`はありません。そのため新しい`sid`が生成され、クッキーの中身が置き換えられます。`Sails.sid`はユーザーエージェントのクッキーが期限切れになったり削除された時にも変更されます。

>Sailsのクッキーのライフスパンは`projectName/config/session.js`の`cookie.maxAge`プロパティを書き換えることでデフォルトから変更することができます（例えば有効期限切れしないなど）


### セッションストアに*Redis*を利用する 

Redisはキーバリュー型のデータベースパッケージでありセッションストアをSailsのインスタンスから分離するのに使えます。セッションの設定をこうすることには２つのメリットが有ります。一つはSailsがリスタートしてもセッションデータが残るということです。もう一つはもしもロードバランサの後ろに複数のSailsインスタンスを用意した時にも全てのインスタンスが統合されたセッションストアにアクセスすることが出来ることです。

Redisをセッションストアにするのを有効化する際はお好みのテキストエディタで`projectName/config/session.js`を開いて`adapter`プロパティのコメントアウトを外します。これだけです。開発中はRedisインスタンスが同じマシーンで動き続けている限り、SailsはセッションストレージとしてRedisを使います。`projectName/config/session.js`で以下のオプションパラメータを設定することで別のRedisインスタンスを指すことも出来ます。:

```
  // host: 'localhost',
  // port: 6379,
  // ttl: <redis session TTL in seconds>,
  // db: 0,
  // pass: <redis auth password>,
  // prefix: 'sess:',

```

これらのプロパティの設定に関してのさらなる情報は[https://github.com/tj/connect-redis](https://github.com/tj/connect-redis)をご覧ください。

#### どのようにセッションのクッキーが作られるかの詳細
クッキーの中身は設定可能な*secret*と`sid`をハッシュすることで作成されます、

>`projectName/config/session.js`でセッションに使う`secret`プロパティを変更することが出来ます。 

Sailsの`sid` (例：`Sails.sid`)はプレーンな`sid`の後に続いて`sid`と`secret`を合わせたもののハッシュがつながっているものになります。これを具体的にするために例を上げてみましょう。Sailsは`234lj232hg234jluy32UUYUHH`と`session secret`である`9238cca11a83d473e10981c49c4f`からなる`sid`を作成するとします。Sailsは単純にこれらの文字列を組み合わせて`AuSosBAbL9t3Ev44EofZtIpiMuV7fB2oi`という`signature`を作ります。ですから、`Sails.sid`は`234lj232hg234jluy32UUYUHH.AuSosBAbL9t3Ev44EofZtIpiMuV7fB2oi`になり、レスポンスヘッダーで`set-cookie`プロパティを送信することでユーザーエージェントのクッキーに保管されます。

**これは何を防いでいるのですか?** これはユーザの`sid`を推測困難にすることで攻撃者が知っている`sid`を利用してユーザになりすした認証リクエストを送信するのを防ぎます。これがもし許されるとユーザーがセッション経由でログインしている際に攻撃者が`sid`を悪用することが可能になってしまいます。

<docmeta name="displayName" value="Sessions">
